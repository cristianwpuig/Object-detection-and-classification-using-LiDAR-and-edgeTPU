////////////////////////////////////////////////////////////////////////////
//   File        : read_data.cpp
//   Description : In this file the functions that read data are provided. First, read_config_file function is used for reading
//                 the configuration file. Second, read_outputs_previous_frame is used for reading the outputs  provided by the
//                 last frame, this is used in the tracking stage. Third, the read_simulated_data perform the read of theLiDAR
//                 dataset. Finally, getName generate the names of the LiDAR data frames.
//
//   Created By: Cristian Wisultschew (https://github.com/cristianwpuig)
////////////////////////////////////////////////////////////////////////////
#include "read_data.hpp"

// Read the configuration file located in ./python_scripts/config.txt
config_params read_config_file(){
	config_params config_params_values;
	std::string aux;

	std::ifstream cFile("../python_scripts/config.txt");
	if (cFile.is_open())
	{
		std::string line;
		while (getline(cFile, line))
		{
			line.erase(std::remove_if(line.begin(), line.end(), ::isspace),line.end());
			if (line[0] == '#' || line[0] == '//' || line.empty()) continue;

			auto delimiterPos = line.find("=");
			auto name = line.substr(0, delimiterPos);
			auto value = line.substr(delimiterPos + 1);

			if (name == "PLANEXZtrue_XYfalse") {
				aux = value;
				config_params_values.PLANEXZtrue_XYfalse = (aux == "true" || aux == "True");
			}
			else if (name == "IS_FIRST_FRAME_TEST") {
				aux = value;
				config_params_values.IS_FIRST_FRAME_TEST = (aux == "true" || aux == "True");
			}
			else if (name == "PLOT_IMAGES") {
				aux = value;
				config_params_values.PLOT_IMAGES = (aux == "true" || aux == "True");
			}
			else if (name == "PRINT_DEBUG_INFO") {
				aux = value;
				config_params_values.PRINT_DEBUG_INFO = (aux == "true" || aux == "True");
			}
			else if (name == "RESET_FRAME_ID") {
				aux = value;
				config_params_values.RESET_FRAME_ID = (aux == "true" || aux == "True");
			}
			else if (name == "STOP_BETWEEN_FRAMES") {
				aux = value;
				config_params_values.STOP_BETWEEN_FRAMES = (aux == "true" || aux == "True");
			}
			else if (name == "DATASET_TYPE") config_params_values.DATASET_TYPE = value;
			else if (name == "POINT_CLOUD_DATASET_DIR") config_params_values.POINT_CLOUD_DATASET_DIR = value;
			else if (name == "DATASET_DATE_TIME") config_params_values.DATASET_DATE_TIME = value;
			else if (name == "STARTING_FRAME") config_params_values.STARTING_FRAME = std::stoi(value);
		}
	}
	else
	{
		std::cerr << "Couldn't open config file for reading.\n";
	}
	return config_params_values;
}

// This function reads from the csv that is used to store the data of each frame.
void read_outputs_previous_frame(object_detection_data *read_prev_frame){
	  // Name of the csv with the data of the previous frame
	  string input_file_name= "../c_algorithm_outputs/object_detection_outputs.csv";
	  const char *cpr = input_file_name.c_str();
	  ifstream fin;
	  string line;
	  fin.open(cpr);
	  int cont_csv = 0;
	  while(!fin.eof()){
		  stringstream ss(line);
		  string token;
		  int cont_inp = 0;
		  // We read the first line: time_vel, if_first_frame, Array Tr_coord_x, -1
		  if (cont_csv == 1){
			  while (getline(ss,token, ','))
			  {
				// We read the time_vel which is the time between frames for calculating the speed of each object
				if (cont_inp == 0)
					read_prev_frame->time_between_frames = double(atof(token.c_str()));
				// We read the if_first_frame variable
				if (cont_inp == 1){
					read_prev_frame->is_first_frame = int(atof(token.c_str()));
					if (read_prev_frame->bounding_box_x_prev_frame.size() != 0)
						read_prev_frame->bounding_box_x_prev_frame.clear();
				}
				// We read the X coordinates of each detected box
				if (cont_inp > 1)
					if (atoi(token.c_str()) != -1)
						read_prev_frame->bounding_box_x_prev_frame.push_back(atoi(token.c_str()));
				cont_inp++;
			  }
		  }
		  // The frame ID number is read
		  if (cont_csv == 4){
			  while (getline(ss,token, ',')){
				  if (atoi(token.c_str()) != -1){
					  read_prev_frame->frame_ID = int(atof(token.c_str()));
				  }
			  }
		  }
		  cont_csv++;
		  fin>>line;
	 }
}

// This function reads the data generated by Velodyne VLP-16
void read_lidar_data(int frame_id, object_detection_data *frame_data_main, config_params config_params_values){
	string dataset_file_with_date = config_params_values.POINT_CLOUD_DATASET_DIR + config_params_values.DATASET_DATE_TIME + "_Velodyne-VLP-16-Data/";
	// Generate the name of the csv containing the points of each frame
	string dataset_file_with_date_frame=getName(frame_id , dataset_file_with_date, config_params_values);
	const char *dataset_file_with_date_frame_aux = dataset_file_with_date_frame.c_str();
	ifstream fin;
	string line;
	std::vector<double> vect;
	fin.open(dataset_file_with_date_frame_aux);
	int cont_csv = 0;

	// Here we store the csv point cloud data
	vector<float> input_lum;
	vector<float> input_x;
	vector<float> input_y;
	vector<float> input_z;

	// The point cloud is read
	while(!fin.eof()){
		if (cont_csv == 0) fin>>line;
		stringstream ss(line);
		string token;
		int cont_inp = 0;
		while (getline(ss,token, ',')){
			if (cont_inp == 0)
				input_x.push_back(atof(token.c_str()));
			if (cont_inp == 1)
				input_y.push_back(atof(token.c_str()));
			if (cont_inp == 2)
				input_z.push_back(atof(token.c_str()));
			if (config_params_values.DATASET_TYPE == "raw"){
				if (cont_inp == 6)
					input_lum.push_back(atof(token.c_str()));
			}
			if (config_params_values.DATASET_TYPE == "preprocessed"){
				if (cont_inp == 3)
					input_lum.push_back(atof(token.c_str()));
			}
			cont_inp++;
		}
	cont_csv++;
	fin>>line;
	}
	double * dat_x;
	double * dat_y;
	double * dat_z;
	double * dat_lum;
	dat_x = new double [ input_x.size()];
	dat_y = new double [ input_x.size()];
	dat_z = new double [ input_x.size()];
	dat_lum = new double [ input_x.size()];
	frame_data_main->lidar_x.clear();
	frame_data_main->lidar_y.clear();
	frame_data_main->lidar_z.clear();
	frame_data_main->lidar_lum.clear();
	for (int i = 0; i<input_x.size(); i++){
		dat_x[i] = static_cast<double>(input_x[i]);
		dat_y[i] = static_cast<double>(input_y[i]);
		dat_z[i] = static_cast<double>(input_z[i]);
		dat_lum[i] = static_cast<double>(input_lum[i]);
		frame_data_main->lidar_x.push_back(dat_x[i]);
		frame_data_main->lidar_y.push_back(dat_y[i]);
		frame_data_main->lidar_z.push_back(dat_z[i]);
		frame_data_main->lidar_lum.push_back(dat_lum[i]);
	}
}


string getName(int num_frame, string CSVdir, config_params config_params_values ){
	string CSVfile;

	if (config_params_values.DATASET_TYPE == "raw"){
		string str_frame_number;
		if ((num_frame + config_params_values.STARTING_FRAME) > 0 and (num_frame + config_params_values.STARTING_FRAME) < 10)
			str_frame_number = "000" + to_string(num_frame + config_params_values.STARTING_FRAME);
		if ((num_frame + config_params_values.STARTING_FRAME) >= 10 and (num_frame + config_params_values.STARTING_FRAME) < 100)
			str_frame_number = "00" + to_string(num_frame + config_params_values.STARTING_FRAME);
		if ((num_frame + config_params_values.STARTING_FRAME) > 100 and (num_frame + config_params_values.STARTING_FRAME) < 1000)
			str_frame_number = "0" + to_string(num_frame + config_params_values.STARTING_FRAME);
		if ((num_frame + config_params_values.STARTING_FRAME) > 1000 and (num_frame + config_params_values.STARTING_FRAME) < 10000)
			str_frame_number = to_string(num_frame + config_params_values.STARTING_FRAME);
		CSVfile =  CSVdir + config_params_values.DATASET_DATE_TIME + "_Velodyne-VLP-16-Data (Frame " + str_frame_number + ").csv";
	}
	else if (config_params_values.DATASET_TYPE == "preprocessed"){
		CSVfile = config_params_values.POINT_CLOUD_DATASET_DIR + "frame_" + to_string(num_frame) + ".csv";
	}
	else{
		cout << "Configuration parameter in ./python_scripts/config.txt DATASET_TYPE not recongized, put raw or preprocessed only" << endl;
	}
	return CSVfile;
}

